<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.38" />

  <title>Java Collections Framework学习笔记之HashMap &middot; Shelby Lee</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://shelbylee.github.io/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://shelbylee.github.io/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://shelbylee.github.io/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://shelbylee.github.io/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://shelbylee.github.io/">Menu</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/contact/"><i class='fa fa-phone fa-fw'></i>Contact</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/topics/"><i class='fa fa-folder fa-fw'></i>Topics</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://shelbylee.github.io/tags/"><i class='fa fa-tags fa-fw'></i>Tags</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href="https://github.com/shelbylee" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2018. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>Java Collections Framework学习笔记之HashMap</h1>
  <h2></h2>
</div>
<div class="content">

  <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>05 Apr 2018, 14:50</time>
  </div>

  

  
  
  
  <div>
    <i class="fa fa-folder fa-fw"></i>
    
      <a class="post-taxonomy-topic" href="https://shelbylee.github.io/topics/jdk%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">JDK源码阅读</a>
    
  </div>
  
  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://shelbylee.github.io/tags/2018-04">2018-04</a>
    
  </div>
  
  

</div>

  

<h2 id="java-collections-framework学习笔记之hashmap">Java Collections Framework学习笔记之HashMap</h2>

<h3 id="一-hashmap简介">一、HashMap简介</h3>

<p>我们看一下官方文档中对HashMap的描述</p>

<pre><code> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This
 * implementation provides all of the optional map operations, and permits
 * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;
 * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is
 * unsynchronized and permits nulls.)  This class makes no guarantees as to
 * the order of the map; in particular, it does not guarantee that the order
 * will remain constant over time.
</code></pre>

<p>总结出一些要点就是：
    - 基于哈希表的 Map 接口的实现。
    - 允许使用 null 值和 null 键。
    - 除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。
    - 不保证顺序
    - 不保证该顺序恒久不变。</p>

<p>HashMap底层的数据结构就是数组+链表+红黑树（JDK 1.8中添加）。
<img src="http://2.bp.blogspot.com/-HIhYA8BWUHk/VZVRW84S2AI/AAAAAAAAAmA/8oydmLJm6M0/s1600/Custom.jpg" alt="image" />
图源：<a href="http://www.java-redefined.com/2015/07/custom-java-hashmap.html">http://www.java-redefined.com/2015/07/custom-java-hashmap.html</a></p>

<p>当新建一个HashMap时，就会初始化一个数组。在这个数组中，存放的是Node类，它拥有指向单独的一个链表的头结点的引用，这个链表是用来解决hash冲突的（如果不同的key被映射到数组中同一位置的话，就将其放入链表中，从而解决冲突）。但是，在JDK 1.8之前的这种做法，即使负载因子和Hash算法设计的再合理，也无法避免会出现链表过长的情况， 一旦链表过长，会严重影响HashMap的性能，所以，在JDK 1.8之后，使用了红黑树这个数据结构，当链表长度大于8时，该链表就会转化成红黑树，利用红黑树快速增删查改的特点提高HashMap的性能。</p>

<pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable
</code></pre>

<p>从定义可以看到，HashMap继承了AbstractMap，实现了Map，Cloneable，Serializable接口。</p>

<p>因为HashMap是不同步的，如果需要考虑线程安全，那么请使用ConcurrentHashMap而不是HashMap。或者可以使用Collections.synchronizedMap()方法返回被指定map支持的同步的map</p>

<pre><code>Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
</code></pre>

<h3 id="二-源码分析-基于jdk1-8">二、源码分析（基于JDK1.8）</h3>

<h4 id="1-成员变量">1. 成员变量</h4>

<pre><code>//默认初始容量是16，必须是2的幂  
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16  
  
//最大容量（必须是2的幂且小于2的30次方，传入容量过大会被这个值替换）  
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;  
  
// 默认加载因子，加载因子就是指哈希表在其容量自动增加之前可以达到多满的一种尺度  
static final float DEFAULT_LOAD_FACTOR = 0.75f;  

// 默认的转换成红黑树的阈值，即链表长度达到该值时，该链表将转换成红黑树
static final int TREEIFY_THRESHOLD = 8;
  
//存储Entry的默认空数组  
static final Entry&lt;?,?&gt;[] EMPTY_TABLE = {};  
  
//存储Entry的数组，长度为2的幂。HashMap采用拉链法实现的，每个Entry的本质是个单向链表  
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;  
  
//HashMap的大小，即HashMap中实际存在的键值对数量 
transient int size;  
  
//阈值，表示所能容纳的key-value对的极限，用于判断是否需要调整HashMap的容量， 
int threshold;  
  
//加载因子实际大小  
final float loadFactor;  
  
//HashMap被修改的次数，用于fail-fast机制  
transient int modCount;  
</code></pre>

<p>其中需要特别注意的是capacity和load factor这两个属性
官方文档中对其描述是：</p>

<pre><code> The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. 

 The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. 
</code></pre>

<ul>
<li>capacity（容量）：就是buckets的数目。</li>
<li>load factor（负载因子）：哈希表中的填满程度。

<ul>
<li>若加载因子设置过大，则填满的元素越多，从而提高了空间利用率，但是冲突的机会增加了，冲突的越多，链表就会变得越长，那么查找效率就会变低；</li>
<li>若加载因子设置过小，则填满的元素越少，那么空间利用率就会降低，表中数据将变得更加稀疏，但是冲突的机会减小了，这样链表就不会太长，查找效率就会变高。</li>
<li>一般，如果机器内存足够，想增加查找速度，可以将load factor设小一点；相反，如果内存不足，并且对查找速度要求不高，可以将load factor设大一点。</li>
</ul></li>
</ul>

<h4 id="2-node类">2. Node类</h4>

<p>Node是一个单链表，实现了Map.Entry接口，其中next也是一个Node对象，用来处理hash冲突，形成一个链表。</p>

<pre><code>    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next; // 指向下一个节点

        // 构造方法：创建一个node
        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        // 判断两个node是否equal（必须key和value都相等）
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
</code></pre>

<h4 id="3-构造方法">3. 构造方法</h4>

<pre><code>    /**
    用初始容量和负载因子创建HashMap
     */
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    /**
    用初始容量创建HashMap，负载因子为默认的0.75
     */
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    /**
    均使用默认值
     */
    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }

    /**
     构造一个新HashMap，这个新HashMap与指定Map有相同的映射
     */
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
</code></pre>

<h4 id="4-确定哈希桶数组索引的位置">4. 确定哈希桶数组索引的位置</h4>

<p>确定位置这部分是很重要的，无论增删查键值对，首先都要定位到哈希桶数组的位置！理想的情况就是数组中每个位置都只有一个元素，这样在用算法求得这个位置后，我们就能直接拿到需要的元素，不用再遍历链表了，这样可以极大地优化查找的效率。</p>

<p>而在源码中，采用的方法就是根据hashCode先计算出hash值，然后根据hash值再求得索引，从而找到位置。</p>

<p>下面是求hash值的源码</p>

<pre><code>    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    }
</code></pre>

<p>（&rdquo;&gt;&gt;&gt;&ldquo;为按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。）
在源码中，hash的计算主要是三步：
1. 取key的hashCode值
2. 高位运算
3. 对1、2进行异或运算得到hash值</p>

<p>下面是计算索引的源码</p>

<pre><code>// 此处取的put方法片段，这里就是用(n - 1) &amp; hash 计算的索引（n为表的长度）
 if ((p = tab[i = (n - 1) &amp; hash]) == null)
</code></pre>

<p>计算方法其实就是取模运算</p>

<p>对于计算索引的取模运算，是一个非常巧妙地运算。我们来具体分析一下：</p>

<p>它是用hash &amp; (n -1)得到索引值，因为HashMap底层数组的长度总是2的n次方（这是HashMap在速度上的优化），所以当n为2的n次方时，这个表达式等价于hash % n，但是&amp;比%具有更高的效率，所以采用的是hash &amp; (n - 1)而不是hash % n。</p>

<p>那么问题来了，为什么hash &amp; (n - 1)可以等价于对n取模呢？</p>

<ul>
<li>首先，假设n，即链表长度，为2的n次方，那么n就可以表示成100&hellip;00的这种样子，那么n - 1就是01111&hellip;11。

<ul>
<li>如果hash &lt; n，&amp;后都是hash本身。</li>
<li>如果hash = n，&amp;后结果为0。</li>
<li>如果hash &gt; n，&amp;过后相当于hash - k*n，即hash % n。</li>
</ul></li>
<li>其次，因为n为2的次幂，是偶数，偶数最后一位是0，而n - 1肯定是奇数，奇数的最后一位是1，这样便保证了hash &amp; (n - 1)的最后一位可能为0也可能为1，这样便可以保证散列的均匀性，即均匀分布在数组table中；而如果n为奇数，则n - 1肯定是偶数，那么它的最后一位肯定是0，这样hash &amp; (n - 1)得到的结果的最后一位肯定是0，即只能为偶数，这样任何hash值都会被映射到数组的偶数下标位置上，这便浪费了近一半的空间！因此，链表长度为2的整数次幂，也是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀的散列。</li>
</ul>

<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE.png" alt="image" />
图源：<a href="https://tech.meituan.com/java-hashmap.html">https://tech.meituan.com/java-hashmap.html</a></p>

<h4 id="5-put方法源码分析">5. put方法源码分析</h4>

<p>put的过程大致是：
- 根据key计算hash值
- 判断tab是否为空，若为空则进行resize()扩容
- 根据hash值计算出索引
- 如果没有碰撞就直接放入
- 如果有碰撞，就先放到链表里
- 若链表长度超过8（默认的TREEIFY_THRESHOLD），则转换成红黑树再放
- 如果key已经存在，就覆盖其oldValue
- 插入成功后，如果size &gt; threshold，就要扩容</p>

<pre><code>    public V put(K key, V value) {
        // 计算hash值
        return putVal(hash(key), key, value, false, true);
    }

    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {

        // tab为哈希表数组，p为我们要找的那个插入位置的节点
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;

        // 若tab为空，就创建一个（进行扩容操作）
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;

        //根据key计算hash值并处理后得到索引，如果表的这个位置为空，则直接插入
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        // 如果不为空
        else {
            Node&lt;K,V&gt; e; K k;
            // 判断key是否存在，如果存在，则直接覆盖其value
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            // 判断该链表是否为TreeNode，如果是，红黑树直接插入键值对
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            // 如果不是，则遍历链表，然后插入
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        // 链表长度大于8，则转换成红黑树，并插入键值对
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            // 插入
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 如果超过阈值，则进行扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>

<p>看到一个美团技术团队画的put方法的流程图很直观，放在这里给大家看一下
<img src="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image" />
图源美团技术团队：<a href="https://tech.meituan.com/java-hashmap.html">https://tech.meituan.com/java-hashmap.html</a></p>

<h4 id="6-get方法源码分析">6. get方法源码分析</h4>

<p>get方法和put方法过程类似，此处不再赘述。</p>

<pre><code>    public V get(Object key) {
        Node&lt;K,V&gt; e;

        // 计算hash值
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

    final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;

        // 如果表非空，并且根据计算出的索引值对应的值非空
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
                // 直接命中
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
                // 未直接命中
            if ((e = first.next) != null) {
                // 在红黑树中get
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                    // 在链表中get
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
</code></pre>

<h4 id="7-resize-的扩容机制">7. resize()的扩容机制</h4>

<ul>
<li><p>为什么要进行resize?</p>

<ul>
<li>因为我们不断地向HashMap中添加元素，所以一定会遇到HashMap无法存储更多元素的情况，这个时候就需要将数组扩大，才能装更多的元素，而Java中数组是无法自动扩容的，所以采用的方法是用一个更大的数组去取代原来的那个小数组。</li>
</ul></li>

<li><p>什么时候进行resize?</p>

<ul>
<li>在put过程中，如果发现当前HashMap的size已经超过了load factor希望占的比例，那么就会进行resize操作，然后重新计算索引，再将节点放入对应位置。</li>
</ul></li>
</ul>

<p>我们看一下官方文档对resize()的描述：</p>

<pre><code>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.
</code></pre>

<p>resize就是用来进行初始化或者将HashMap扩大为2倍。因为我们使用的是2次幂的扩展（长度扩展为原来的2倍），所以元素要么在原来的位置不变，要么在原位置再移动2次幂的位置。</p>

<p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt="image" />
图源： <a href="https://tech.meituan.com/java-hashmap.html">https://tech.meituan.com/java-hashmap.html</a></p>

<p>(a)：扩容前，通过(n - 1) &amp; hash1/2得到key1和key2的索引位置</p>

<p>(b)：扩容后的索引位置</p>

<p>图中可以看到，在扩容后，n - 1在高位多了1bit，这是因为数组被扩大了2倍。在扩容后会重新对索引进行计算，因为n值变了，所以按位与计算后的索引也会有所变化，变化如图：
<img src="https://cloud.githubusercontent.com/assets/1736354/6958301/519be432-d93c-11e4-85bb-dff0a03af9d3.png" alt="image" />
图源： <a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p>

<p>所以，我们可以看出，在扩容后，我们不需要重新计算hash，只需看原来的hash值新增的那个bit是1还是0就行，是0的话索引没变，是1的话索引变成“原索引+oldCap”。这种设计方法省去了重新计算hash的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>

<pre><code>    final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            // 超过最大值就不再扩充了，就只好随你碰撞去吧
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 没超过最大值，就扩充为原来的2倍
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        // 计算新的resize上限
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            // 把每个bucket都移动到新的buckets中
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            // 原索引
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            // 原索引+oldCap
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        // 原索引放到bucket里
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        // 原索引+oldCap放到bucket里
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre>

<h3 id="三-hashmap的遍历方式">三、HashMap的遍历方式</h3>

<pre><code>    Map&lt;String, Integer&gt;() map = new HashMap&lt;&gt;();
    String key = null;
    Integer value = null;
</code></pre>

<ol>
<li>遍历Entry</li>
</ol>

<p>这种方式可以一次性获取到key和value</p>

<pre><code>        Iterator itr = map.entrySet().iterator();

        while (itr.hasNext()) {
            Map.Entry entry = (Map.Entry)itr.next();
            key = (String)entry.getKey();
            value = (Integer)entry.getValue();
            System.out.println(key + &quot;=&gt;&quot; + value);
        }
</code></pre>

<ol>
<li>遍历key</li>
</ol>

<p>同样可以获取到key和value，只不过value是通过get方法获得的</p>

<pre><code>        Iterator itr = map.keySet().iterator();

        while (itr.hasNext()) {
            key = (String)itr.next();
            value = (Integer)map.get(key);
            System.out.println(key + &quot;=&gt;&quot; + value);
        }
</code></pre>

<ol>
<li>遍历value</li>
</ol>

<p>只能获取到value</p>

<pre><code>        Collection c = map.values();
        Iterator itr = c.iterator();

        while (itr.hasNext()) {
            value = (Integer)itr.next();
            System.out.println(value);
        }
</code></pre>

<h3 id="四-关于hashmap的线程安全性">四、关于HashMap的线程安全性</h3>

<p>在 一、HashMap简介 中我已经提到了，HashMap不是线程安全的，它在被设计的时候就没有考虑线程安全，因为这本来就不是一个并发容器，相应的并发容器是ConcurrentHashMap，那么，HashMap的线程不安全主要体现在哪儿呢？</p>

<p>最著名的一个就是高并发环境下的死循环问题，具体是在resize时产生的。</p>

<p>这种死循环产生的主要原因是因为1.7的resize中，新的table采用的插入方式是队头插入（LIFO，后进先出），比如元素为{3,5,7,9}，插入后就是{9,7,5,9}，会将链表顺序逆置，它这样做主要是为了防止遍历链表尾部，因为resize本来就是创建了一个新的table，所以对于元素的顺序不关心，因此采用队头插入的方式，如果是正常的从尾部插入的话，还需要先找到尾部的位置，增加了遍历的消耗，而resize又正好不在乎元素顺序，所以就使用的队头插入的方式。</p>

<p>但是这种方式带来了一个问题，就是死循环，具体死循环怎么产生的我就不赘述了，因为网上有很多关于这个的具体分析，我要说的是，在JDK 1.8中，HashMap除了加入了红黑树这个数据结构外还有一些其他的调整，在resize时对链表的操作，变成了两对指针对两个链表分别操作</p>

<pre><code>                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;          
</code></pre>

<p>因为增加了xxTail指针，所以可以随时找到尾部，避免遍历尾部，因此可以直接在尾部插入，因而避免了死循环问题。</p>

<p>不过这不代表JDK 1.8 的HashMap就是线程安全了的，因为很明显还存在比如并发时元素的覆盖之类的问题，所以多线程环境下还是建议使用ConcurrentHashMap。</p>

<h3 id="五-总结">五、总结</h3>

<ol>
<li>什么时候需要使用HashMap？它有什么特点？</li>
</ol>

<p>HashMap是基于Map接口的实现，它适合于像字典这样的key-value关系的映射。特点主要是，它的key和value都允许为null，并且它是不同步的，HashMap中存储着Entry(hash, key, value, next)对象，而且HashMap无法保证顺序。</p>

<ol>
<li>HashMap的原理</li>
</ol>

<p>HashMap的底层数据结构是数组+链表+红黑树，红黑树是在JDK 1.8之后加上的。当新建一个HashMap后，会创建一个数组，这个数组存放着单链表的头结点的引用，这个链表是为了解决冲突，就是有不同的key被映射到数组中同一个位置的时候，就会放到链表中。但是在JDK 1.8之前，即使你负载因子和Hash算法设计的再合理，也很难避免会出现一个链表过长的情况，因此，在JDK 1.8中加入了红黑树，在链表长度大于默认的阈值8的时候，会将链表转换成红黑树，利用红黑树的快速增删查改来提高HashMap的性能。</p>

<ol>
<li>get和put的原理</li>
</ol>

<p>applicant: 他们是通过key的hashCode()方法得到hash值，然后将(n - 1)和hash值进行按位与运算得到下标，从而获得哈希桶的位置。如果产生碰撞，就用key.equals()方法在链表或树中查找对应的节点。</p>

<ol>
<li>具体描述一下怎么获得的哈希桶的位置的</li>
</ol>

<p>第一步是先根据key的hashCode()方法得到hashCode值，然后将获取的hashCode值和进行高位运算后的结果进行异或操作（ key.hashCode()) ^ (h &gt;&gt;&gt; 16)）从而得到hash值。第二步是根据hash值计算出索引，其实就是一个取模操作，但是它取模的方法是用(n - 1) &amp; hash，这个方法是非常巧妙的，它等价于hash % n，但是它采用&amp;比%更高效。</p>

<ol>
<li>如果HashMap的size超过了load factor定义的容量 怎么办？</li>
</ol>

<p>会重新resize为一个是原来两倍大小的HashMap，并且重新调用hash方法。</p>

<p>References:</p>

<ul>
<li><a href="http://blog.csdn.net/eson_15/article/details/51158865">http://blog.csdn.net/eson_15/article/details/51158865</a></li>
<li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh">http://tool.oschina.net/apidocs/apidoc?api=jdk-zh</a></li>
<li><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></li>
<li><a href="http://zhangshixi.iteye.com/blog/672697">http://zhangshixi.iteye.com/blog/672697</a></li>
<li><a href="https://tech.meituan.com/java-hashmap.html">https://tech.meituan.com/java-hashmap.html</a></li>
</ul>


  
<div class="prev-next-post pure-g">
  <div class="pure-u-1-24" style="text-align: left;">
    
  </div>
  <div class="pure-u-10-24">
    
  </div>
  <div class="pure-u-2-24">
    &nbsp;
  </div>
  <div class="pure-u-10-24">
    
  </div>
  <div class="pure-u-1-24" style="text-align: right;">
    
  </div>
</div>



  
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'shelbylee';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>

</div>
</div>
<script src="https://shelbylee.github.io/js/ui.js"></script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-103593285-1', 'auto');
  ga('send', 'pageview');

</script>





</body>
</html>

